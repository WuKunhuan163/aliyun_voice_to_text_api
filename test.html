<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é˜¿é‡Œäº‘è¯­éŸ³è¯†åˆ«æµ‹è¯•</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        .form-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        input[type="text"], input[type="password"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }
        button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background-color: #45a049;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .log-area {
            background-color: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            height: 300px;
            overflow-y: scroll;
            font-family: monospace;
            font-size: 12px;
            white-space: pre-wrap;
        }
        .result-area {
            background-color: #e7f3ff;
            border: 1px solid #b3d9ff;
            border-radius: 4px;
            padding: 10px;
            margin-top: 10px;
            min-height: 50px;
        }
        .error {
            color: red;
        }
        .success {
            color: green;
        }
        .info {
            color: blue;
        }
    </style>
</head>
<body>
    <h1>é˜¿é‡Œäº‘è¯­éŸ³è¯†åˆ«æµ‹è¯•é¡µé¢</h1>
    
    <div class="form-group">
        <label for="appKey">AppKey:</label>
        <input type="text" id="appKey" placeholder="è¾“å…¥æ‚¨çš„AppKey">
    </div>
    
    <div class="form-group">
        <label for="accessKeyId">Access Key ID:</label>
        <input type="text" id="accessKeyId" placeholder="è¾“å…¥æ‚¨çš„Access Key ID">
    </div>
    
    <div class="form-group">
        <label for="accessKeySecret">Access Key Secret:</label>
        <input type="password" id="accessKeySecret" placeholder="è¾“å…¥æ‚¨çš„Access Key Secret">
    </div>
    
    <div class="form-group">
        <button id="testTokenBtn">æµ‹è¯•Tokenè·å–</button>
        <button id="recordBtn" disabled>å¼€å§‹å½•éŸ³</button>
        <button id="stopBtn" disabled>åœæ­¢å½•éŸ³</button>
        <button id="testFileBtn">æµ‹è¯•æ–‡ä»¶ä¸Šä¼ è¯†åˆ«</button>
    </div>
    
    <div class="form-group">
        <label>è°ƒè¯•æ—¥å¿—:</label>
        <div id="logArea" class="log-area"></div>
    </div>
    
    <div class="form-group">
        <label>è¯†åˆ«ç»“æœ:</label>
        <div id="resultArea" class="result-area">ç­‰å¾…è¯†åˆ«ç»“æœ...</div>
    </div>
    
    <input type="file" id="fileInput" accept="audio/*" style="display: none;">

    <script>
        class VoiceRecognitionTest {
            constructor() {
                this.initElements();
                this.setupEventListeners();
                this.audioChunks = [];
                this.mediaRecorder = null;
                this.currentToken = null;
                this.apiUrl = '/api/recognize';
            }
            
            initElements() {
                this.appKey = document.getElementById('appKey');
                this.accessKeyId = document.getElementById('accessKeyId');
                this.accessKeySecret = document.getElementById('accessKeySecret');
                this.testTokenBtn = document.getElementById('testTokenBtn');
                this.recordBtn = document.getElementById('recordBtn');
                this.stopBtn = document.getElementById('stopBtn');
                this.testFileBtn = document.getElementById('testFileBtn');
                this.logArea = document.getElementById('logArea');
                this.resultArea = document.getElementById('resultArea');
                this.fileInput = document.getElementById('fileInput');
            }
            
            setupEventListeners() {
                this.testTokenBtn.addEventListener('click', () => this.testTokenAPI());
                this.recordBtn.addEventListener('click', () => this.startRecording());
                this.stopBtn.addEventListener('click', () => this.stopRecording());
                this.testFileBtn.addEventListener('click', () => this.testFileUpload());
                this.fileInput.addEventListener('change', (e) => this.handleFileSelect(e));
            }
            
            log(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const className = type === 'error' ? 'error' : type === 'success' ? 'success' : 'info';
                const logEntry = `[${timestamp}] ${message}\n`;
                
                const span = document.createElement('span');
                span.className = className;
                span.textContent = logEntry;
                
                this.logArea.appendChild(span);
                this.logArea.scrollTop = this.logArea.scrollHeight;
                
                console.log(`[${type.toUpperCase()}]`, message);
            }
            
            clearLog() {
                this.logArea.innerHTML = '';
            }
            
            async testTokenAPI() {
                this.clearLog();
                this.log('ğŸ”„ å¼€å§‹æµ‹è¯•Token API...');
                
                const appKey = this.appKey.value.trim();
                const accessKeyId = this.accessKeyId.value.trim();
                const accessKeySecret = this.accessKeySecret.value.trim();
                
                if (!appKey || !accessKeyId || !accessKeySecret) {
                    this.log('âŒ è¯·å¡«å†™æ‰€æœ‰å¿…éœ€å­—æ®µ', 'error');
                    return;
                }
                
                try {
                    this.log('ğŸ“¤ å‘é€Tokenè¯·æ±‚...');
                    this.log(`   AppKey: ${appKey}`);
                    this.log(`   AccessKeyId: ${accessKeyId.substring(0, 8)}...`);
                    this.log(`   AccessKeySecret: ${accessKeySecret.substring(0, 8)}...`);
                    
                    const response = await fetch(this.apiUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            audioData: [], // ç©ºéŸ³é¢‘æ•°æ®ï¼Œåªæµ‹è¯•Token
                            appKey: appKey,
                            accessKeyId: accessKeyId,
                            accessKeySecret: accessKeySecret
                        })
                    });
                    
                    this.log(`ğŸ“¡ HTTPå“åº”çŠ¶æ€: ${response.status}`);
                    
                    const result = await response.json();
                    this.log('ğŸ“„ APIå“åº”:', JSON.stringify(result, null, 2));
                    
                    if (result.success) {
                        this.log('âœ… Tokenè·å–æˆåŠŸ!', 'success');
                        this.currentToken = result.data.tokenExpireTime;
                        this.recordBtn.disabled = false;
                    } else {
                        this.log(`âŒ Tokenè·å–å¤±è´¥: ${result.error}`, 'error');
                    }
                    
                } catch (error) {
                    this.log(`âŒ è¯·æ±‚å¤±è´¥: ${error.message}`, 'error');
                }
            }
            
            async startRecording() {
                this.log('ğŸ¤ å¼€å§‹å½•éŸ³...');
                this.audioChunks = [];
                
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            sampleRate: 16000,
                            channelCount: 1,
                            echoCancellation: true,
                            noiseSuppression: true
                        }
                    });
                    
                    this.log('âœ… è·å–éº¦å…‹é£æƒé™æˆåŠŸ');
                    
                    this.mediaRecorder = new MediaRecorder(stream, {
                        mimeType: 'audio/webm;codecs=opus'
                    });
                    
                    this.mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            this.audioChunks.push(event.data);
                            this.log(`ğŸ“Š éŸ³é¢‘æ•°æ®å—: ${event.data.size} bytes`);
                        }
                    };
                    
                    this.mediaRecorder.onstop = () => {
                        this.log('â¹ï¸ å½•éŸ³åœæ­¢ï¼Œå¼€å§‹å¤„ç†...');
                        this.processRecording();
                    };
                    
                    this.mediaRecorder.start(1000); // æ¯ç§’æ”¶é›†ä¸€æ¬¡æ•°æ®
                    this.recordBtn.disabled = true;
                    this.stopBtn.disabled = false;
                    
                    this.log('ğŸ”´ å½•éŸ³å¼€å§‹...');
                    
                } catch (error) {
                    this.log(`âŒ å½•éŸ³å¤±è´¥: ${error.message}`, 'error');
                }
            }
            
            stopRecording() {
                if (this.mediaRecorder && this.mediaRecorder.state !== 'inactive') {
                    this.mediaRecorder.stop();
                    this.recordBtn.disabled = false;
                    this.stopBtn.disabled = true;
                    this.log('â¸ï¸ åœæ­¢å½•éŸ³...');
                }
            }
            
            async processRecording() {
                try {
                    const audioBlob = new Blob(this.audioChunks, { type: 'audio/webm' });
                    this.log(`ğŸ“ éŸ³é¢‘æ–‡ä»¶å¤§å°: ${audioBlob.size} bytes`);
                    this.log(`ğŸ“ éŸ³é¢‘ç±»å‹: ${audioBlob.type}`);
                    
                    // è½¬æ¢ä¸ºå­—èŠ‚æ•°ç»„
                    const arrayBuffer = await this.blobToArrayBuffer(audioBlob);
                    const audioByteArray = Array.from(new Uint8Array(arrayBuffer));
                    
                    this.log(`ğŸ”„ è½¬æ¢ä¸ºå­—èŠ‚æ•°ç»„: ${audioByteArray.length} bytes`);
                    this.log(`ğŸ“Š å‰10ä¸ªå­—èŠ‚: [${audioByteArray.slice(0, 10).join(', ')}]`);
                    
                    await this.recognizeAudio(audioByteArray);
                    
                } catch (error) {
                    this.log(`âŒ éŸ³é¢‘å¤„ç†å¤±è´¥: ${error.message}`, 'error');
                }
            }
            
            async blobToArrayBuffer(blob) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsArrayBuffer(blob);
                });
            }
            
            async recognizeAudio(audioByteArray) {
                try {
                    this.log('ğŸš€ å¼€å§‹è¯­éŸ³è¯†åˆ«...');
                    this.resultArea.textContent = 'è¯†åˆ«ä¸­...';
                    
                    const requestBody = {
                        audioData: audioByteArray,
                        appKey: this.appKey.value.trim(),
                        accessKeyId: this.accessKeyId.value.trim(),
                        accessKeySecret: this.accessKeySecret.value.trim(),
                        format: 'pcm',
                        sampleRate: 16000
                    };
                    
                    this.log(`ğŸ“¤ å‘é€è¯†åˆ«è¯·æ±‚: ${audioByteArray.length} bytes`);
                    
                    const response = await fetch(this.apiUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(requestBody)
                    });
                    
                    this.log(`ğŸ“¡ è¯†åˆ«å“åº”çŠ¶æ€: ${response.status}`);
                    
                    const result = await response.json();
                    this.log('ğŸ“„ è¯†åˆ«ç»“æœ:', JSON.stringify(result, null, 2));
                    
                    if (result.success && result.data && result.data.text) {
                        this.log(`âœ… è¯†åˆ«æˆåŠŸ: "${result.data.text}"`, 'success');
                        this.resultArea.innerHTML = `<strong>è¯†åˆ«ç»“æœ:</strong> ${result.data.text}`;
                    } else {
                        this.log(`âŒ è¯†åˆ«å¤±è´¥: ${result.error || 'æœªçŸ¥é”™è¯¯'}`, 'error');
                        this.resultArea.innerHTML = `<strong>è¯†åˆ«å¤±è´¥:</strong> ${result.error || 'æœªçŸ¥é”™è¯¯'}`;
                    }
                    
                } catch (error) {
                    this.log(`âŒ è¯†åˆ«è¯·æ±‚å¤±è´¥: ${error.message}`, 'error');
                    this.resultArea.innerHTML = `<strong>è¯·æ±‚å¤±è´¥:</strong> ${error.message}`;
                }
            }
            
            testFileUpload() {
                this.fileInput.click();
            }
            
            async handleFileSelect(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                this.log(`ğŸ“ é€‰æ‹©æ–‡ä»¶: ${file.name} (${file.size} bytes, ${file.type})`);
                
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    const audioByteArray = Array.from(new Uint8Array(arrayBuffer));
                    
                    this.log(`ğŸ”„ æ–‡ä»¶è½¬æ¢ä¸ºå­—èŠ‚æ•°ç»„: ${audioByteArray.length} bytes`);
                    
                    await this.recognizeAudio(audioByteArray);
                    
                } catch (error) {
                    this.log(`âŒ æ–‡ä»¶å¤„ç†å¤±è´¥: ${error.message}`, 'error');
                }
            }
        }
        
        // åˆå§‹åŒ–æµ‹è¯•å·¥å…·
        const tester = new VoiceRecognitionTest();
        
        // é¡µé¢åŠ è½½å®Œæˆåæ˜¾ç¤ºè¯´æ˜
        window.addEventListener('load', () => {
            tester.log('ğŸŒŸ é˜¿é‡Œäº‘è¯­éŸ³è¯†åˆ«æµ‹è¯•å·¥å…·å·²åŠ è½½');
            tester.log('ğŸ“ ä½¿ç”¨è¯´æ˜:');
            tester.log('   1. å¡«å†™AppKeyå’ŒAccessKeyä¿¡æ¯');
            tester.log('   2. ç‚¹å‡»"æµ‹è¯•Tokenè·å–"éªŒè¯é…ç½®');
            tester.log('   3. ç‚¹å‡»"å¼€å§‹å½•éŸ³"è¿›è¡Œè¯­éŸ³è¯†åˆ«æµ‹è¯•');
            tester.log('   4. æˆ–ç‚¹å‡»"æµ‹è¯•æ–‡ä»¶ä¸Šä¼ è¯†åˆ«"ä¸Šä¼ éŸ³é¢‘æ–‡ä»¶æµ‹è¯•');
            tester.log('');
        });
    </script>
</body>
</html>
